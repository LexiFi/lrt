<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dynt (dynt.Dynt)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">dynt</a> &#x00BB; Dynt</nav><h1>Module <code>Dynt</code></h1><p>Dynamic types for OCaml.</p><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#constructing-dynamic-types">Constructing dynamic types</a></li><li><a href="#using-dynamic-types">Using dynamic types</a></li><li><a href="#paths">Paths</a></li><li><a href="#type-representation">Type representation</a></li><li><a href="#unification-and-pattern-matching">Unification and pattern matching</a></li><li><a href="#type-equality">Type equality</a></li><li><a href="#open-dynt">open Dynt</a></li></ul></nav></header><section><header><h3 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h3><p>TODO: Pitch</p></header></section><section><header><h3 id="constructing-dynamic-types"><a href="#constructing-dynamic-types" class="anchor"></a>Constructing dynamic types</h3><p>TODO: Describe usage of <code>[@@deriving t]</code>.</p><p>Runtime representations of the basic OCaml types can be found in the <a href="Std/index.html"><code>Std</code></a> module. These definitions are generally required, when you use the <code>[@@deriving t]</code> syntax extension.</p></header><dl><dt class="spec module" id="module-Std"><a href="#module-Std" class="anchor"></a><code><span class="keyword">module </span><a href="Std/index.html">Std</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Dynamic type representations for standard ocaml types.</p></dd></dl></section><section><header><h3 id="using-dynamic-types"><a href="#using-dynamic-types" class="anchor"></a>Using dynamic types</h3><p>TODO: Some words on the example applications.</p></header><dl><dt class="spec module" id="module-Print"><a href="#module-Print" class="anchor"></a><code><span class="keyword">module </span><a href="Print/index.html">Print</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Dynamic printing.</p></dd></dl><dl><dt class="spec module" id="module-Variant"><a href="#module-Variant" class="anchor"></a><code><span class="keyword">module </span><a href="Variant/index.html">Variant</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Ocaml syntax compatible representation of values.</p></dd></dl><dl><dt class="spec module" id="module-Json"><a href="#module-Json" class="anchor"></a><code><span class="keyword">module </span><a href="Json/index.html">Json</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Json compatible representation of values.</p></dd></dl><dl><dt class="spec module" id="module-Check"><a href="#module-Check" class="anchor"></a><code><span class="keyword">module </span><a href="Check/index.html">Check</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A quickcheck-like library for OCaml.</p></dd></dl></section><section><header><h3 id="paths"><a href="#paths" class="anchor"></a>Paths</h3><p>We include an implementation of lenses and list of lenses: <a href="Path/index.html"><code>Path</code></a> enables access of values in nested tuples, records and constructors. Additionally, paths can be used to access nested types (see <a href="Xtype/index.html#val-project_path"><code>Xtype.project_path</code></a>).</p><p>Paths are constructed using the <code>[?path: .]</code> syntax extension.</p></header><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module </span><a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Access deeply nested types and values.</p></dd></dl></section><section><header><h3 id="type-representation"><a href="#type-representation" class="anchor"></a>Type representation</h3><p>Dynt comes with different representations of runtime types. Depending on the application, one might use one or another.</p><p><a href="Stype/index.html#type-t"><code>Stype.t</code></a> or <a href="index.html#type-stype"><code>stype</code></a> in short are an untyped representation of dynamic types. Stypes are easy to construct, serializable and allow to write for unsafe but powerful code. Most users want to avoid this interface.</p><p><a href="Ttype/index.html#type-t"><code>Ttype.t</code></a> or <a href="index.html#type-ttype"><code>ttype</code></a> in short extend the untyped <a href="index.html#type-stype"><code>stype</code></a> with an OCaml type. Ttypes are constructed by the <code>[@@deriving t]</code> syntax extension and can be used to safely consume APIs that make use of dynamic types.</p><p><a href="Xtype/index.html#type-t"><code>Xtype.t</code></a> enable safe inspection of dynamic types. Xtypes are used to implement APIs that make use of dynamic types.</p></header><dl><dt class="spec module" id="module-Stype"><a href="#module-Stype" class="anchor"></a><code><span class="keyword">module </span><a href="Stype/index.html">Stype</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Untyped representation of types.</p></dd></dl><dl><dt class="spec module" id="module-Ttype"><a href="#module-Ttype" class="anchor"></a><code><span class="keyword">module </span><a href="Ttype/index.html">Ttype</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Typed representation of types.</p></dd></dl><dl><dt class="spec module" id="module-Xtype"><a href="#module-Xtype" class="anchor"></a><code><span class="keyword">module </span><a href="Xtype/index.html">Xtype</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Visitable representation of types.</p></dd></dl></section><section><header><h3 id="unification-and-pattern-matching"><a href="#unification-and-pattern-matching" class="anchor"></a>Unification and pattern matching</h3><p>TODO: Describe Unify and Matcher</p></header><dl><dt class="spec module" id="module-Unify"><a href="#module-Unify" class="anchor"></a><code><span class="keyword">module </span><a href="Unify/index.html">Unify</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Unification of dynamic types.</p></dd></dl><dl><dt class="spec module" id="module-Matcher"><a href="#module-Matcher" class="anchor"></a><code><span class="keyword">module </span><a href="Matcher/index.html">Matcher</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Pattern matching on dynamic types.</p></dd></dl></section><section><header><h3 id="type-equality"><a href="#type-equality" class="anchor"></a>Type equality</h3><p>Some of the other modules are able to check for type equality of dynamically crafted types. Such type equalities are inherently out of reach for the OCaml type system. They are &quot;transported back&quot; with help of the <a href="TypEq/index.html"><code>TypEq</code></a> module.</p><p>A value of type <code>('a, 'b) TypEq.t</code> can be interpreted as equality proof for <code>'a</code> and <code>'b</code>. OCaml's type system accepts this proof when you open the GADT constructor <a href="TypEq/index.html#type-t.Eq"><code>TypEq.t.Eq</code></a>. An unwrap may look like the following.</p><pre><code class="ml">let plus: type a. int -&gt; a -&gt; (a, int) TypEq.t -&gt; int =
 fun a b eq -&gt;
  let TypEq.Eq = eq in
  a + b</code></pre></header><dl><dt class="spec module" id="module-TypEq"><a href="#module-TypEq" class="anchor"></a><code><span class="keyword">module </span><a href="TypEq/index.html">TypEq</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Type equalities.</p></dd></dl></section><section><header><h3 id="open-dynt"><a href="#open-dynt" class="anchor"></a>open Dynt</h3><p>Place <code>open Dynt</code> at the toplevel of your modules to have the dynamic representation of basic ocaml types available when you need them.</p></header><dl><dt class="spec type" id="type-stype"><a href="#type-stype" class="anchor"></a><code><span class="keyword">type </span>stype</code><code><span class="keyword"> = </span><a href="Stype/index.html#type-t">Stype.t</a></code></dt><dt class="spec type" id="type-ttype"><a href="#type-ttype" class="anchor"></a><code><span class="keyword">type </span>'a ttype</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec type" id="type-dynamic"><a href="#type-dynamic" class="anchor"></a><code><span class="keyword">type </span>dynamic</code><code><span class="keyword"> = </span><a href="Ttype/index.html#type-dynamic">Ttype.dynamic</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-dynamic.Dyn" class="anchored"><td class="def constructor"><a href="#type-dynamic.Dyn" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Dyn</span><span class="keyword"> : </span><span class="type-var">'a</span> <a href="index.html#type-ttype">ttype</a><span class="keyword"> * </span><span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-dynamic">dynamic</a></code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="index.html#module-Std">Std</a></code></span></summary><aside></aside><aside><p>Dynamic type representations for standard ocaml types.</p></aside><section><header><h3 id="pervasives"><a href="#pervasives" class="anchor"></a>Pervasives</h3></header><dl><dt class="spec value" id="val-unit_t"><a href="#val-unit_t" class="anchor"></a><code><span class="keyword">val </span>unit_t : unit <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-bool_t"><a href="#val-bool_t" class="anchor"></a><code><span class="keyword">val </span>bool_t : bool <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-int_t"><a href="#val-int_t" class="anchor"></a><code><span class="keyword">val </span>int_t : int <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-string_t"><a href="#val-string_t" class="anchor"></a><code><span class="keyword">val </span>string_t : string <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-float_t"><a href="#val-float_t" class="anchor"></a><code><span class="keyword">val </span>float_t : float <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-char_t"><a href="#val-char_t" class="anchor"></a><code><span class="keyword">val </span>char_t : char <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-nativeint_t"><a href="#val-nativeint_t" class="anchor"></a><code><span class="keyword">val </span>nativeint_t : nativeint <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-int32_t"><a href="#val-int32_t" class="anchor"></a><code><span class="keyword">val </span>int32_t : int32 <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-int64_t"><a href="#val-int64_t" class="anchor"></a><code><span class="keyword">val </span>int64_t : int64 <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-option_t"><a href="#val-option_t" class="anchor"></a><code><span class="keyword">val </span>option_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-list_t"><a href="#val-list_t" class="anchor"></a><code><span class="keyword">val </span>list_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-array_t"><a href="#val-array_t" class="anchor"></a><code><span class="keyword">val </span>array_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt></dl></section><section><header><h3 id="stdlib"><a href="#stdlib" class="anchor"></a>Stdlib</h3></header><dl><dt class="spec value" id="val-lazy_t"><a href="#val-lazy_t" class="anchor"></a><code><span class="keyword">val </span>lazy_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Stdlib.Lazy.t <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-hashtbl_t"><a href="#val-hashtbl_t" class="anchor"></a><code><span class="keyword">val </span>hashtbl_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Stdlib.Hashtbl.t <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt></dl></section></details></div></div></div></section></div></body></html>