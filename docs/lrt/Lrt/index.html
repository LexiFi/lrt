<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lrt (lrt.Lrt)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lrt</a> &#x00BB; Lrt</nav><h1>Module <code>Lrt</code></h1><p>LexiFi runtime types.</p><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#build-runtime-types">Build runtime types</a><ul><li><a href="#free-variable-handling">Free variable handling</a></li><li><a href="#abstract-types">Abstract types</a></li><li><a href="#patching">Patching</a></li><li><a href="#properties">Properties</a></li></ul></li><li><a href="#use-runtime-types">Use runtime types</a><ul><li><a href="#type-representation">Type representation</a></li><li><a href="#unification">Unification</a></li><li><a href="#pattern-matching">Pattern matching</a></li><li><a href="#type-equality">Type equality</a></li></ul></li><li><a href="#paths">Paths</a></li><li><a href="#open-lrt">open Lrt</a></li></ul></nav></header><section><header><h3 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h3><p>It is often useful to get access to types at runtime in order to implement generic type-driven operations. A typical example is a generic pretty-printer. Unfortunately, the OCaml compiler does not keep type information at runtime. At LexiFi, we have extended OCaml to support runtime types. This extension has been in use for years and is now a key element in many of our interesting components, such as our automatic GUI framework (which derives GUIs from type definitions) or our high-level database layer (which derives SQL schema from type definitions, and exposes a well-typed interface for queries). This extension is tightly integrated with the OCaml typechecker, which allows the compiler to synthesize the runtime type representations with minimal input from the programmer.</p><p>This package makes the features of our extension available to other OCaml users without relying on a modified compiler. Instead, it only relies on a PPX syntax extension that synthesizes the runtime representation of types from their syntactic definition with a deriving-like approach.</p><p>Based on this new implementation we are able to open-source the infrastructure we have developed around the machinery of runtime types as well as libraries built upon them.</p></header></section><section><header><h3 id="build-runtime-types"><a href="#build-runtime-types" class="anchor"></a>Build runtime types</h3><p>Runtime representations of OCaml types are built using the <code>lrt.deriving</code> PPX syntax extension. In the simplest case, you only have to attach a <code> [@@deriving t] </code> attribute to the type declaration.</p><pre><code class="ml"># #require &quot;lrt.deriving&quot;;;
# open Lrt.Std;;
# type foo = { bar: string } [@@deriving t] ;;
type foo = { bar: string }
val foo_t : foo ttype
# type t = foo * int [@@deriving t] ;;
val t : t ttype</code></pre><p>Runtime representations of the basic OCaml types can be found in the <a href="Std/index.html"><code>Std</code></a> module. These definitions are generally required, when you use the <code>[@@deriving t]</code> syntax extension.</p></header><div class="spec module" id="module-Std"><a href="#module-Std" class="anchor"></a><code><span class="keyword">module </span><a href="Std/index.html">Std</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><section><header><h4 id="free-variable-handling"><a href="#free-variable-handling" class="anchor"></a>Free variable handling</h4><p>Types with free variables are represented as closures with one <a href="index.html#type-ttype"><code>ttype</code></a> argument per free variable. Most APIs, like <a href="Print/index.html"><code>Print</code></a> for dynamic printing, consume closed types.</p><pre><code class="ml"># type 'a tree =
+   | Leave of 'a
+   | Node of 'a tree list
+ [@@deriving t];;
val tree_t : 'a ttype -&gt; 'a tree ttype
# let () = Print.show ~t:(tree_t int_t) (Node [Leave 0; Leave 1]);;
Node [Leave 0; Leave 1]</code></pre><p>Stating the types in function application style might be a bit unintuitive. Thus there is an extension point that translates types to applications. Instead of the previous example, you can also write the following.</p><pre><code class="ml"># let () = Print.show ~t:[%t: int tree] (Node [Leave 0; Leave 1]);;
Node [Leave 0; Leave 1]</code></pre></header></section><section><header><h4 id="abstract-types"><a href="#abstract-types" class="anchor"></a>Abstract types</h4><p>We attempt to support abstract types. Whenever you want to hide the actual type definition from the derived ttype, you have to annotate the type declarations with <code> [@@abstract] </code>.</p><pre><code class="ml"># module M : sig
+   type t [@@deriving t]
+ end = struct
+   type t = int array [@@deriving t]
+ end;;
module M : sig type t val t : t ttype end
# Format.printf &quot;%a\n&quot; Ttype.print M.t;;
int array
# module N : sig
+   type t [@@deriving t]
+ end = struct
+   type t = int array [@@abstract] [@@deriving t]
+ end;;
module N : sig type t val t : t ttype end
# Format.printf &quot;%a\n&quot; Ttype.print M.t;;
//toplevel//.N.t</code></pre><p>It is worth to note that abstract types are represented by a string. You can trick the naming mechanism into producing indistinguishable abstract runtime types for distinct OCaml types. You can bypass the name generation by providing a string argument to the abstract annotation.</p><pre><code class="ml"># type abstract = int [@@abstract &quot;uid&quot;] [@@deriving t];;
val abstract_t : abstract ttype
# Format.printf &quot;%a\n&quot; Ttype.print abstract_t;;
uid</code></pre><p>In case you want to expose an abstract ttype, but use a non-abstract version within the module, we recommend to define two types - one non-abstract for internal use and one abstract for satisfying the interface - as outlined below.</p><pre><code class="ml"># module M : sig
+   type hidden [@@deriving t]
+ end = struct
+   type visible = string list
+   and hidden = visible [@@abstract] [@@deriving t];;
+   (* [visible] represents a string list here. *)
+ end;;</code></pre></header></section><section><header><h4 id="patching"><a href="#patching" class="anchor"></a>Patching</h4><p>It happens frequently, that ttypes are not available under the expected name. For such cases, we provide the <code>@patch</code> annotation.</p><pre><code class="ml"># lazy_t;;
- : 'a ttype -&gt; 'a lazy_t ttype = &lt;fun&gt;
# type 'a lazy_pair = ('a * 'a) Lazy.t [@patch lazy_t] [@@deriving t];;
type 'a lazy_pair = ('a * 'a) lazy_t
val lazy_pair_t : 'a ttype -&gt; 'a lazy_pair ttype = &lt;fun&gt;</code></pre><p>When using an external type that has no corresponding ttype we recommend to introduce an abstract alias and use it as replacement.</p><pre><code class="ml">type external = External.t [@@abstract] [@@deriving t]
type local = (External.t [@patch external_t]) list [@@deriving t]</code></pre></header></section><section><header><h4 id="properties"><a href="#properties" class="anchor"></a>Properties</h4><p>Our runtime types support attachments of properties. The behaviour of some APIs can be tweaked by providing certain properties. Properties can be added to core types, record fields and constructors. Keep in mind the binding precedence of annotations.</p><pre><code class="ml">type sum =
  | A of int [@prop {key1= &quot;binds to constructor A&quot;}]
  | B of (int [@prop {key2= &quot;binds to type int&quot;}])
and record =
  { c : int [@prop {key3= &quot;binds to field c&quot;}]
  ; d : (int [@prop {key4= &quot;binds&quot;; key5=&quot;to int&quot;}])
  }
[@@deriving t]</code></pre></header></section></section><section><header><h3 id="use-runtime-types"><a href="#use-runtime-types" class="anchor"></a>Use runtime types</h3><p>We provide some example modules that consume runtime types. The best entry point for further exploring the features of Lrt is probably the implementation of <a href="Json/index.html#type-conv"><code>Json.conv</code></a>.</p><p><a href="Print/index.html"><code>Print</code></a> is used as generic dynamic printer. It is able to print arbitrary values based on their runtime type. Values of abstract types can be printed by registering abstract printers.</p><p><a href="Variant/index.html"><code>Variant</code></a> may be used to serialize values in an OCaml compatible syntax. Provided a runtime type, the module is able to serialize and deserialize arbitrary values of non-abstract type. Custom (de)variantizers for abstract types can be registered globally.</p><p><a href="Json/index.html"><code>Json</code></a> provides serialization like <a href="Variant/index.html"><code>Variant</code></a> but targets JSON as intermediate format. Additionally, it uses the latest features provided by <a href="Matcher/index.html"><code>Matcher</code></a> to allow the registration of custom converters for any type.</p><p><a href="Check/index.html"><code>Check</code></a> is a Quickcheck implementation that derives value generators from runtime types. Additionally, it is able to generate random runtime types and thereby values of random type. This is useful for testing functions that are meant to handle any type.</p></header><dl><dt class="spec module" id="module-Print"><a href="#module-Print" class="anchor"></a><code><span class="keyword">module </span><a href="Print/index.html">Print</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Dynamic printing.</p></dd></dl><dl><dt class="spec module" id="module-Variant"><a href="#module-Variant" class="anchor"></a><code><span class="keyword">module </span><a href="Variant/index.html">Variant</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Ocaml syntax compatible representation of values.</p></dd></dl><dl><dt class="spec module" id="module-Json"><a href="#module-Json" class="anchor"></a><code><span class="keyword">module </span><a href="Json/index.html">Json</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Json compatible representation of values.</p></dd></dl><dl><dt class="spec module" id="module-Check"><a href="#module-Check" class="anchor"></a><code><span class="keyword">module </span><a href="Check/index.html">Check</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A quickcheck-like library for OCaml.</p></dd></dl><section><header><h4 id="type-representation"><a href="#type-representation" class="anchor"></a>Type representation</h4><p>Lrt comes with different representations of runtime types. Depending on the application, one might use one or another.</p><p><a href="Stype/index.html#type-t"><code>Stype.t</code></a> or <a href="index.html#type-stype"><code>stype</code></a> in short are an untyped runtime representation of OCaml types. Stypes are easy to construct, serializable and allow to write unsafe but powerful code. Most users want to avoid this interface.</p><p><a href="Ttype/index.html#type-t"><code>Ttype.t</code></a> or <a href="index.html#type-ttype"><code>ttype</code></a> in short extend the untyped <a href="index.html#type-stype"><code>stype</code></a> with an OCaml type. Ttypes can be built using the <code>[@@deriving t]</code> syntax extension and can be used to safely consume APIs that make use of runtime types.</p><p><a href="Xtype/index.html#type-t"><code>Xtype.t</code></a> enable safe inspection of runtime types. Xtypes are used to implement APIs that make use of runtime types.</p></header><dl><dt class="spec module" id="module-Stype"><a href="#module-Stype" class="anchor"></a><code><span class="keyword">module </span><a href="Stype/index.html">Stype</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Untyped representation of types.</p></dd></dl><dl><dt class="spec module" id="module-Ttype"><a href="#module-Ttype" class="anchor"></a><code><span class="keyword">module </span><a href="Ttype/index.html">Ttype</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Typed representation of types.</p></dd></dl><dl><dt class="spec module" id="module-Xtype"><a href="#module-Xtype" class="anchor"></a><code><span class="keyword">module </span><a href="Xtype/index.html">Xtype</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Visitable representation of types.</p></dd></dl></section><section><header><h4 id="unification"><a href="#unification" class="anchor"></a>Unification</h4><p>The <a href="Unify/index.html"><code>Unify</code></a> module holds functors that allow to unify an unclosed runtime type with a closed one. This was particularly interesting for implementing the abstract type handling of <a href="Print/index.html"><code>Print</code></a> and <a href="Variant/index.html"><code>Variant</code></a>. It may be that <a href="Matcher/index.html"><code>Matcher</code></a> is strictly more powerful and <a href="Unify/index.html"><code>Unify</code></a> can be dropped.</p></header><dl><dt class="spec module" id="module-Unify"><a href="#module-Unify" class="anchor"></a><code><span class="keyword">module </span><a href="Unify/index.html">Unify</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Unification of runtime types.</p></dd></dl></section><section><header><h4 id="pattern-matching"><a href="#pattern-matching" class="anchor"></a>Pattern matching</h4><p><a href="Matcher/index.html"><code>Matcher</code></a> provides a mechanism for storing data indexed by type using as discrimination tree. The runtime type provided as key during insertion may contain free variables. Data can be retrieved from the store by providing a closed type. During retrieval, the key type is unified with the type used for insertion.</p><p>This provides a mechanism similar to OCaml pattern matching but for runtime types.</p></header><dl><dt class="spec module" id="module-Matcher"><a href="#module-Matcher" class="anchor"></a><code><span class="keyword">module </span><a href="Matcher/index.html">Matcher</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Pattern matching on runtime types.</p></dd></dl></section><section><header><h4 id="type-equality"><a href="#type-equality" class="anchor"></a>Type equality</h4><p>Some of the other modules are able to check for type equality of dynamically crafted types. Such type equalities are inherently out of reach for the OCaml type system. They are &quot;transported back&quot; with help of the <a href="TypEq/index.html"><code>TypEq</code></a> module.</p><p>A value of type <code>('a, 'b) TypEq.t</code> can be interpreted as equality proof for <code>'a</code> and <code>'b</code>. OCaml's type system accepts this proof when you open the GADT constructor <a href="TypEq/index.html#type-t.Eq"><code>TypEq.t.Eq</code></a>. An unwrap may look like the following.</p><pre><code class="ml">let plus: type a. int -&gt; a -&gt; (a, int) TypEq.t -&gt; int =
 fun a b eq -&gt;
  let TypEq.Eq = eq in
  a + b</code></pre></header><dl><dt class="spec module" id="module-TypEq"><a href="#module-TypEq" class="anchor"></a><code><span class="keyword">module </span><a href="TypEq/index.html">TypEq</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Type equalities.</p></dd></dl></section></section><section><header><h3 id="paths"><a href="#paths" class="anchor"></a>Paths</h3><p>We include an implementation of lenses and list of lenses: <a href="Path/index.html"><code>Path</code></a> enables access to values in nested tuples, records and constructors. Additionally, paths can be used to access nested types (see <a href="Xtype/index.html#val-project_path"><code>Xtype.project_path</code></a>).</p><p>Paths can be built using the <code>lrt.path</code> syntax extension.</p><pre><code class="ml"># #require &quot;lrt.path&quot;;;
# type t = A of {b: int array list * string}
+ let p1 : (t, string) Path.t = [%path? [ A b; (_, []) ]]
+ let p2 : (t, int)    Path.t = [%path? [ A b; ([], _); [0]; [|1|] ]]
+ let Path.{get; set} = Path.lens p2
+ let () =
    if get (A {b= ([ [|0; 42|]; [||] ], &quot;clutter&quot;)}) = Some 42
    then print_endline &quot;success&quot; ;;
success</code></pre><p>Further instructions can be found within the <a href="Path/index.html"><code>Path</code></a> module.</p></header><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module </span><a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Access deeply nested types and values.</p></dd></dl></section><section><header><h3 id="open-lrt"><a href="#open-lrt" class="anchor"></a>open Lrt</h3><p>We recommend to place <code>open Lrt</code> at the toplevel of your modules to have the runtime representation of basic OCaml types and all the lrt tools available when you need them. If you do not want to have the <code>Lrt.*</code> modules cluttering your namespace use <code>open Lrt.Std</code>.</p></header><dl><dt class="spec type" id="type-stype"><a href="#type-stype" class="anchor"></a><code><span class="keyword">type </span>stype</code><code><span class="keyword"> = </span><a href="Stype/index.html#type-t">Stype.t</a></code></dt><dt class="spec type" id="type-ttype"><a href="#type-ttype" class="anchor"></a><code><span class="keyword">type </span>'a ttype</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec type" id="type-dynamic"><a href="#type-dynamic" class="anchor"></a><code><span class="keyword">type </span>dynamic</code><code><span class="keyword"> = </span><a href="Ttype/index.html#type-dynamic">Ttype.dynamic</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-dynamic.Dyn" class="anchored"><td class="def constructor"><a href="#type-dynamic.Dyn" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Dyn</span><span class="keyword"> : </span><span class="type-var">'a</span> <a href="index.html#type-ttype">ttype</a><span class="keyword"> * </span><span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-dynamic">dynamic</a></code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="index.html#module-Std">Std</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="index.html#module-Std">Std</a></code></span></summary><aside></aside><aside><p>Dynamic type representations for standard ocaml types.</p></aside><section><header><h3 id="pervasives"><a href="#pervasives" class="anchor"></a>Pervasives</h3></header><dl><dt class="spec value" id="val-unit_t"><a href="#val-unit_t" class="anchor"></a><code><span class="keyword">val </span>unit_t : unit <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-bool_t"><a href="#val-bool_t" class="anchor"></a><code><span class="keyword">val </span>bool_t : bool <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-int_t"><a href="#val-int_t" class="anchor"></a><code><span class="keyword">val </span>int_t : int <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-string_t"><a href="#val-string_t" class="anchor"></a><code><span class="keyword">val </span>string_t : string <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-float_t"><a href="#val-float_t" class="anchor"></a><code><span class="keyword">val </span>float_t : float <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-char_t"><a href="#val-char_t" class="anchor"></a><code><span class="keyword">val </span>char_t : char <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-nativeint_t"><a href="#val-nativeint_t" class="anchor"></a><code><span class="keyword">val </span>nativeint_t : nativeint <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-int32_t"><a href="#val-int32_t" class="anchor"></a><code><span class="keyword">val </span>int32_t : int32 <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-int64_t"><a href="#val-int64_t" class="anchor"></a><code><span class="keyword">val </span>int64_t : int64 <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-option_t"><a href="#val-option_t" class="anchor"></a><code><span class="keyword">val </span>option_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-list_t"><a href="#val-list_t" class="anchor"></a><code><span class="keyword">val </span>list_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-array_t"><a href="#val-array_t" class="anchor"></a><code><span class="keyword">val </span>array_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt></dl></section><section><header><h3 id="stdlib"><a href="#stdlib" class="anchor"></a>Stdlib</h3></header><dl><dt class="spec value" id="val-lazy_t"><a href="#val-lazy_t" class="anchor"></a><code><span class="keyword">val </span>lazy_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Stdlib.Lazy.t <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt><dt class="spec value" id="val-hashtbl_t"><a href="#val-hashtbl_t" class="anchor"></a><code><span class="keyword">val </span>hashtbl_t : <span class="type-var">'a</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="Ttype/index.html#type-t">Ttype.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Stdlib.Hashtbl.t <a href="Ttype/index.html#type-t">Ttype.t</a></code></dt></dl></section></details></div></div></div></details></div></div></div></section></div></body></html>